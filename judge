#!/bin/bash

######## Default Config ########

CC='gcc'
CFLAGS='-lm -O2 -Wall -fdiagnostics-color=always'

CXX='g++'
CXXFLAGS='-std=c++17 -O2 -Wall -fdiagnostics-color=always'

JAVA='java'
JAVAC='javac'
JFLAGS='-Xlint:all'
JRUN=''

PY='python'
PYFLAGS='-m py_compile'
PYRUN=''

indent='  '

get_test_dir() {
	local src_file="${1}"
	echo "_$(tr '[:upper:]' '[:lower:]' <<< "${src_file%.*}")"
}

######## Utility Functions ########

# Output a message to standard error, with optional indentation and coloring.
log() {
	local message="${1}"
	local num_indents="${2:0}"
	local tput_letter="${3}"

	if [ "${tput_letter}" ]; then
		local tp_var="tp_${tput_letter}"
		local prefix="${!tp_var}"
		local suffix="${tp_n}"
	else
		local prefix=''
		local suffix=''
	fi

	local i
	for (( i = num_indents; i > 0; i-- )); do
		>&2 echo -n "${indent}"
	done

	>&2 echo "${prefix}${message}${suffix}"
}

ilog() {
	(( interactive )) && log "$@"
}

die() {
	log "${1}" 0 r
	exit 1
}

die_usage() {
	log "${1}" 0 r
	log "Try 'judge --help' for more information"
	exit 1
}

# Remove the file extension and make the parent directory explicit.
base_path() {
	local file="${1}"

	local base="$(basename "${file}")"
	echo "$(dirname "${1}")/${base%.*}"
}

# Display a file if it is not empty.
show_file() {
	local file="${1}"
	local description="${2}"
	local num_indents="${3}"
	local to_stdout="${4:0}"

	[ -s "${file}" ] || return

	log "${2} (${tp_s}${file}${tp_n}):" "${num_indents}"

	if (( to_stdout )); then
		cat "${file}"
	else
		local indents=""
		local i
		for (( i = num_indents + 1; i > 0; i-- )); do
			indents+="${indent}"
		done

		# HACK: The colored diff output sometimes contains ANSI escape sequences
		# after the final \n, so s/^/${indents}/ results in incorrect indentation.
		>&2 sed -Ez -e 's/\t/        /g' -e "s/[^\n]*\n/${indents}&/g" < "${file}"
	fi
}

# Format an array representing a command and its arguments.
format_cmd() {
	declare -n array="${1}"
	(( ${#array[@]} > 0 )) && printf '%q' "${array[0]}"
	(( ${#array[@]} > 1 )) && printf ' %q' "${array[@]:1}"
}

# Read a file from standard input, terminated by a delimiter. If the delimiter is a newline
# character (\n), read until the end of input. Return zero if at least one line was read.
read_file() {
	local file="${1}"
	local delimiter="${2}"
	local description="${3}"
	local num_indents="${4}"

	log "${description} (${tp_s}${file}${tp_n}):" "${num_indents}"
	if (( interactive )); then
		local message="Enter each line of data, terminated by "
		case "${delimiter}" in
			'')
				message+="a blank line."
				;;
			$'\n')
				message+="EOF (Control+D)."
				;;
			*)
				message+="a line containing only '${delimiter}' (without the quotes)."
				;;
		esac
		log "${message}" "${num_indents}" s
	fi

	local num_lines=0
	local line
	while IFS= read -r line; do
		[ "${line}" == "${delimiter}" ] && break
		echo "${line}" >> "${file}"
		(( num_lines++ ))
	done

	(( num_lines > 0 ))
}

heading() {
	log "${1}:" 0 b
}

enable_color() {
	tp_n="$(tput sgr0)"
	tp_b="$(tput bold)"
	tp_r="$(tput setaf 1)"
	tp_g="$(tput setaf 2)"
	tp_y="$(tput setaf 3)"
	tp_s="$(tput setaf 8)"
}

######## Judge Functions ########

# List basenames of files in a directory.
find_files() {
	local dir="${1}"
	shift

	find "${dir}" -maxdepth 1 -type f "$@" -printf '%f\n'
}

# List test files in the order they should be run.
list_test_files() {
	local dir="${1}"

	find_files "${dir}" -name '[0-9]*.in' | sort -g
	find_files "${dir}" -name '[^0-9_]*.in'
	find_files "${dir}" -name '_*.in'
}

get_compile_cmd() {
	local src_file="${1}"

	case "${src_file}" in
		*.c)
			compile_cmd=(${CC} ${CFLAGS} "${src_file}" -o "${src_file%.*}")
			;;
		*.cc|*.cpp|*.cxx)
			compile_cmd=(${CXX} ${CXXFLAGS} "${src_file}" -o "${src_file%.*}")
			;;
		*.java)
			compile_cmd=(${JAVAC} ${JFLAGS} "${src_file}")
			;;
		*.py)
			compile_cmd=(${PY} ${PYFLAGS} "${src_file}")
			;;
		*)
			return 1
			;;
	esac
}

get_run_cmd() {
	local src_file="${1}"

	case "${src_file}" in
		*.c|*.cc|*.cpp|*.cxx)
			run_cmd=("./${src_file%.*}")
			;;
		*.java)
			local class_name="${src_file%.java}"
			run_cmd=(${JAVA} ${JRUN} "${class_name}")
			;;
		*.py)
			run_cmd=(${PY} ${PYRUN} "${src_file}")
			;;
		*)
			return 1
			;;
	esac
}

make_tests() {
	local test_dir="${1}"

	(( make_tests )) || return 0

	heading "Creating test files"

	mkdir -p "${test_dir}"

	ilog 'Enter the delimiter you will use to separate each file you type in. Press Enter to use a blank line.' 1 s
	log "Delimiter:" 1
	local delimiter
	IFS= read -r delimiter

	local tests_made=0
	local test_num
	for (( test_num = 1; ; test_num++ )); do
		local test_base="${test_dir}/${test_num}"
		local test_in="${test_base}.in"
		local test_out="${test_base}.out"

		if [ -f "${test_in}" ] || [ -f "${test_out}" ]; then
			log "Test ${test_num} already exists." 1 s
			continue
		fi

		if ! read_file "${test_in}" "${delimiter}" "Test ${test_num} input" 1; then
			log "No lines entered. Test creation canceled." 1 s
			break
		fi
		if ! read_file "${test_out}" "${delimiter}" "Test ${test_num} output" 1; then
			log "No lines entered. The output file for this test was not created." 1 y
			break
		fi
		(( tests_made++ ))
	done

	log "Created ${tests_made} test(s)." 1
}

test_input() {
	local tmp_dir="${1}"

	heading "Creating a test from standard input"

	if read_file "${tmp_dir}/_judge_stdin.in" $'\n' 'Test input' 1; then
		log 'Created test input from standard input.' 1 s
	else
		log 'No lines entered. Test creation canceled.' 1 y
	fi
}

copy_tests() {
	local test_dir="${1}"
	local tmp_dir="${2}"

	heading "Loading tests"

	local num_loaded=0
	local test_file
	for test_file in "${test_dir}"/*; do
		local test_in="${test_file%.*}.in"
		local test_out="${test_file%.*}.out"
		case "${test_file}" in
			*.in)
				if [ -f "${test_out}" ]; then
					cp "${test_in}" "${test_out}" "${tmp_dir}"
					(( num_loaded++ ))
				else
					log "Ignoring input file '${test_in}' without corresponding output file '${test_out}'." 1 y
				fi
				;;

			*.out)
				if ! [ -f "${test_in}" ]; then
					log "Ignoring output file '${test_out}' without corresponding input file '${test_in}'." 1 y
				fi
				;;
			*)
				log "Ignoring unknown file '${test_file}' in test directory." 1 y
				;;
		esac
	done

	log "Loaded ${num_loaded} test(s)." 1 s
}

compile() {
	local dir="$(dirname "${1}")"
	local src_file="$(basename "${1}")"

	pushd "${dir}" &> /dev/null

	local compile_out="_compile.out"
	local compile_err="_compile.err"

	heading 'Compiling'

	local compile_status
	if get_compile_cmd "${src_file}"; then
		log "$(format_cmd compile_cmd)" 1 s

		"${compile_cmd[@]}" > "${compile_out}" 2> "${compile_err}"
		compile_status="$?"

		(( compile_status )) && log "Exit status ${compile_status}." 1 r

		show_file "${compile_out}" 'Standard output' 1
		show_file "${compile_err}" 'Standard error' 1
	else
		log "Cannot compile '${src_file}': language not recognized." 1 r
		compile_status=1
	fi

	popd &> /dev/null

	(( compile_status )) && log "Compilation failed." 1 r
	return "${compile_status}"
}

run_tests() {
	local src_file="${1}"

	heading 'Running tests'

	if ! get_run_cmd "$(basename "${src_file}")"; then
		log "Cannot run '$(basename "${src_file}")': language not recognized." 1 r
		return 1
	else
		log "$(format_cmd run_cmd)" 1 s
	fi

	(( use_builtin_time )) && log "To show memory usage, install GNU time." 1 s

	local test_in
	while read -r test_in; do
		run "${tmp_dir}/${test_in}"
	done < <(list_test_files "${tmp_dir}")
}

run() {
	local dir="$(dirname "${1}")"
	local test_in="$(basename "${1}")"

	pushd "${dir}" &> /dev/null

	local test_name="${test_in%.in}"

	local test_my="${test_name}.my"
	local test_err="${test_name}.err"
	local test_time="${test_name}.time"

	>&2 echo -n "${indent}Test ${test_name}: "

	if (( use_builtin_time )); then
		local TIMEFORMAT='%R'
		{
			time "${run_cmd[@]}" < "${test_in}" > "${test_my}" 2> "${test_err}"
		} 2> "${test_time}"
	else
		command time -o "${test_time}" -q -f '%e\n%M' \
			"${run_cmd[@]}" < "${test_in}" > "${test_my}" 2> "${test_err}"
	fi
	local run_status="$?"

	local run_stats
	if (( use_builtin_time )); then
		run_stats="$(<"${test_time}") s"
	else
		{
			local run_sec run_kb
			read -r run_sec
			read -r run_kb
		} < "${test_time}"
		run_stats="${run_sec} s, $(bc <<< "scale=1; ${run_kb} / 1024") MB"
	fi

	local test_out="${test_name}.out"
	if [ -f "${test_out}" ]; then
		local diff_width=$(( $(wc -L < "${test_my}") + $(wc -L < "${test_out}") + 16 ))
		local test_diff="${test_name}.diff"
		diff --color=always --side-by-side --width=${diff_width} \
			"${test_my}" "${test_out}" > "${test_diff}"
		local diff_status="$?"
	else
		local diff_status=2
	fi

	local test_status
	case "${diff_status}" in
		0)
			test_status="${tp_g}passed"
			;;
		1)
			test_status="${tp_r}failed"
			;;
		2)
			test_status="${tp_s}unknown"
			;;
	esac
	log "${test_status}${tp_n} (${run_stats})." 0

	(( run_status )) && log "Exit status ${run_status}." 2 r

	case "${diff_status}" in
		1)
			show_file "${test_in}" "Standard input" 2
			show_file "${test_diff}" "diff '$(basename "${test_my}")' '$(basename "${test_out}")'" 2
			;;
		2)
			show_file "${test_my}" "Standard output" 2 1
			;;
	esac

	show_file "${test_err}" "Standard error" 2

	popd &> /dev/null

	return "${diff_status}"
}

usage() {
	cat << EOF
Usage: judge [OPTION]... SOURCE_CODE
Compile and run source code against test inputs.

    -h, --help          Show this help message.
    -i, --test-input    Read a test input from standard input.
    -t, --make-tests    Use standard input to generate test input/output files.
        --version       Show version information.
EOF
}

version() {
	cat << EOF
local-cp-judge 0.2.3

Copyright (C) 2021 Justin Yao Du.
Licensed under the MIT License.

GitHub: https://github.com/justinyaodu/local-cp-judge
EOF
}

main() {
	enable_color

	# Determine whether standard input is coming from a terminal.
	[ ! -t 0 ]
	interactive="$?"

	# Determine whether the standalone time utility is available. If it isn't, use the Bash builtin.
	command -v time &> /dev/null
	use_builtin_time="$?"

	test_input=0
	make_tests=0

	local orig_src_file=""

	while (( $# )); do
		local arg="${1}"
		shift
		case "${arg}" in
			-h|--help)
				usage
				exit
				;;
			-i|--test-input)
				test_input=1
				continue
				;;
			-t|--make-tests)
				make_tests=1
				continue
				;;
			--version)
				version
				exit
				;;
			-*)
				die_usage "Unrecognized option '${arg}'."
				;;
			*)
				orig_src_file="${arg}"
				(( $# )) && die_usage "Trailing argument(s): '$@'."
				break
				;;
		esac
	done

	[ "${orig_src_file}" ] || die_usage "No source code file specified."
	[ -f "${orig_src_file}" ] || die "File does not exist: '${orig_src_file}'."

	local orig_dir="$(dirname "${orig_src_file}")"
	local src_file="$(basename "${orig_src_file}")"

	local judgerc="${orig_dir}/.judgerc"
	[ -f "${judgerc}" ] && source "${judgerc}"

	local test_dir="${orig_dir}/$(get_test_dir "${src_file}")"
	test_dir="${test_dir#./}"

	if (( !interactive && !test_input && !make_tests )); then
		local message='Standard input is not a terminal, but neither --test-input nor'
		message+=' --make-tests were specified. If anything is piped to standard input,'
		message+=' it will be interpreted as a test input.'
		test_input=2
		log "${message}" 1 y
	fi

	(( make_tests )) && make_tests "${test_dir}"

	local tmp_dir="$(mktemp --tmpdir -d "judge-$(date +'%Y-%m-%d-%H-%M-%S')-XXXXXXXXXX")"

	if [ -d "${test_dir}" ]; then
		copy_tests "${test_dir}" "${tmp_dir}"
	elif (( !test_input )); then
		log "Test directory does not exist: '${test_dir}'. Interpreting standard input as a test input." 0 y
		test_input=2
	fi

	(( test_input )) && test_input "${tmp_dir}"

	cp "${orig_src_file}" "${tmp_dir}"
	local tmp_src_file="${tmp_dir}/${src_file}"
	compile "${tmp_src_file}" || return

	run_tests "${tmp_src_file}"
}

main "$@"
